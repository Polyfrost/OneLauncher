// @ts-nocheck 
// This file has been generated by Specta. DO NOT EDIT.

import { createTauRPCProxy as createProxy, type InferCommandOutput } from 'taurpc'
type TAURI_CHANNEL<T> = (response: T) => void


export type ClusterError = { type: "InvalidVersion"; data: string } | { type: "MissingJavaVersion"; data: string } | { type: "ClusterDownloading"; data: string } | { type: "ClusterAlreadyRunning"; data: string }

export type ClusterModel = { id: bigint; folder_name: string; stage: ClusterStage; created_at: string; group_id: bigint | null; name: string; mc_version: string; mc_loader: GameLoader; mc_loader_version: string | null; last_played: string | null; overall_played: bigint | null; icon_url: Icon | null; setting_profile_name: string | null; linked_pack_id: string | null; linked_pack_version: string | null }

export type ClusterStage = "notready" | "downloading" | "repairing" | "ready"

export type ClusterUpdate = { name: string | null; icon_url: Icon | null }

export type CreateCluster = { name: string; mc_version: string; mc_loader: GameLoader; mc_loader_version: string | null; icon: Icon | null }

export type CryptoError = { type: "InvalidHash"; data: string } | { type: "InvalidAlgorithm"; data: string }

export type DaoError = { type: "NotFound"; data: string } | { type: "AlreadyExists"; data: string } | { type: "InvalidValue"; data: string }

export type DbVec = T[]

export type DirectoryError = { type: "BaseDir"; data: string }

export type DiscordError = { type: "MissingClientId"; data: string } | { type: "ConnectError"; data: string }

export type Filters = { game_versions: string[] | null; loaders: GameLoader[] | null; categories: string[] | null; package_types: PackageType[] | null }

export type GameLoader = "vanilla" | "forge" | "neoforge" | "quilt" | "fabric" | "legacyfabric"

export type IOError = { type: "InvalidAbsolutePath"; data: string } | { type: "IOErrorWrapper"; data: string } | { type: "IOError"; data: string } | { type: "DeserializeError"; data: string } | { type: "AsyncZipError"; data: string }

export type Icon = string

export type IncompatiblePackageType = { type: "McVersion"; data: string } | { type: "Loader"; data: string }

export type IngressError = { type: "NotFound"; data: string }

export type IngressPayload = { id: string; message: string; ingress_type: IngressType; percent: number | null; total: number }

export type IngressType = { Download: { file_name: string } } | "JavaPrepare" | "JavaCheck" | "JavaLocate" | "MinecraftDownload" | { PrepareCluster: { cluster_name: string } }

export type JavaError = { type: "ParseVersion"; data: string } | { type: "Execute"; data: string } | { type: "MissingJava"; data: string }

export type LauncherError = { type: "DirError"; data: DirectoryError } | { type: "IOError"; data: IOError } | { type: "IngressError"; data: IngressError } | { type: "JavaError"; data: JavaError } | { type: "CryptoError"; data: CryptoError } | { type: "DiscordError"; data: DiscordError } | { type: "MetadataError"; data: MetadataError } | { type: "ClusterError"; data: ClusterError } | { type: "MinecraftAuthError"; data: MinecraftAuthError } | { type: "ProcessError"; data: ProcessError } | { type: "PackageError"; data: PackageError } | { type: "DaoError"; data: DaoError } | { type: "SerdeError"; data: string } | { type: "AnyhowError"; data: string } | { type: "DbError"; data: string } | { type: "ReqwestError"; data: string } | { type: "InterpulseError"; data: string } | { type: "RegexError"; data: string } | { type: "SemaphoreError"; data: string } | { type: "UrlError"; data: string } | { type: "TauriError"; data: string }

export type ManagedPackage = { id: string; slug: string; provider: Provider; package_type: PackageType; name: string; short_desc: string; body: string; version_ids: string[]; mc_versions: string[]; loaders: GameLoader[]; icon_url: string | null; created: string; updated: string; client: PackageSide; server: PackageSide; categories: string[]; license: PackageLicense | null; author: PackageAuthor; links: PackageLinks; status: PackageStatus; downloads: bigint; gallery: PackageGallery[] }

export type ManagedUser = { id: string; username: string; url?: string | null; avatar_url?: string | null; bio?: string | null; is_organization_user?: boolean; role?: string | null }

export type ManagedVersion = { version_id: string; project_id: string; display_name: string; display_version: string; changelog: string | null; dependencies: ManagedVersionDependency[]; mc_versions: string[]; release_type: PackageReleaseType; loaders: GameLoader[]; published: string; downloads: bigint; files: ManagedVersionFile[] }

export type ManagedVersionDependency = { version_id: string | null; project_id: string | null; file_name: string | null; dependency_type: PackageDependencyType }

export type ManagedVersionFile = { sha1: string; url: string; file_name: string; primary: boolean; size: bigint }

export type MessageLevel = "Info" | "Warn" | "Error"

export type MessagePayload = { level: MessageLevel; message: string }

export type MetadataError = { type: "FetchError"; data: string } | { type: "NotModdedManifest"; data: string } | { type: "NotVanillaManifest"; data: string } | { type: "ParseError"; data: string } | { type: "NoMatchingLoader"; data: string } | { type: "NoMatchingVersion"; data: string }

export type MinecraftAuthError = { type: "PublicKeyReading"; data: string } | { type: "PKCS8Error"; data: string } | { type: "SerializeError"; data: string } | { type: "DeserializeError"; data: string } | { type: "RequestError"; data: string } | { type: "SigningError"; data: string } | { type: "HashError"; data: string } | { type: "SessionIdError"; data: string }

/**
 * A structure of all needed Minecraft credentials for logging in and account management.
 */
export type MinecraftCredentials = { 
/**
 * The uuid of the credentials.
 */
id: string; 
/**
 * The username of the Minecraft account.
 */
username: string; 
/**
 * The access token as a String.
 */
access_token: string; 
/**
 * The refresh token as a string for [`MinecraftState#refresh`].
 */
refresh_token: string; 
/**
 * The time that the access token expires as a [`DateTime<Utc>`].
 */
expires: string }

export type PackageAuthor = { Team: { team_id: string; org_id: string | null } } | { Users: ManagedUser[] }

export type PackageDependencyType = "required" | "optional" | "embedded" | "incompatible"

/**
 * https://api.modrinth.com/v2/tag/donation_platform
 */
export type PackageDonationPlatform = "patreon" | "buymeacoffee" | "paypal" | "github" | "kofi" | "other"

export type PackageDonationUrl = { id: PackageDonationPlatform; url: string }

export type PackageError = { type: "NoPrimaryFile"; data: string } | { type: "IsModPack"; data: string } | { type: "Incompatible"; data: IncompatiblePackageType }

export type PackageGallery = { url: string; thumbnail_url: string; title: string | null; description: string | null; featured: boolean | null }

/**
 * https://spdx.org/licenses/
 */
export type PackageLicense = { id: string; name: string; url: string | null }

/**
 * https://docs.curseforge.com/rest-api/#tocS_ModLinks
 */
export type PackageLinks = { website: string | null; issues: string | null; source: string | null; wiki: string | null; donation: PackageDonationUrl[] | null; discord: string | null }

export type PackageModel = { hash: string; file_name: string; version_id: string; published_at: string; display_name: string; display_version: string; package_type: PackageType; provider: Provider; package_id: string; mc_versions: DbVec<string>; mc_loader: DbVec<GameLoader>; icon: Icon | null }

export type PackageReleaseType = "release" | "beta" | "alpha"

export type PackageSide = "unknown" | "required" | "optional" | "unsupported"

export type PackageStatus = "active" | "abandoned"

export type PackageType = "mod" | "resourcepack" | "shader" | "datapack" | "modpack"

export type Paginated<T> = { total: bigint; offset: bigint; limit: bigint; items: T[] }

export type Process = { pid: number; started_at: string; cluster_id: bigint; post_hook: string | null; account_id: string }

export type ProcessError = { type: "HookUnsuccessful"; data: string } | { type: "NoPid"; data: string }

export type ProcessPayload = { type: "Starting"; command: string } | { type: "Started"; process: Process } | { type: "Stopped"; pid: number; exit_code: number } | { type: "Output"; pid: number; output: string }

export type ProfileUpdate = { res: Resolution | null; force_fullscreen: boolean | null; mem_max: number | null; launch_args: string | null; launch_env: string | null; hook_pre: string | null; hook_wrapper: string | null; hook_post: string | null }

export type Provider = "Modrinth" | "Curseforge" | "SkyClient"

export type Resolution = { width: number; height: number }

export type SearchQuery = { query: string | null; offset: bigint | null; limit: bigint | null; sort: Sort | null; filters: Filters | null }

export type SearchResult = { project_id: string; project_type: string; slug: string; author: string; title: string; description: string; categories: string[]; display_categories: string[]; versions: string[]; downloads: bigint; icon_url: string; date_created: string; date_modified: string; latest_version: string; license: string; client_side: PackageSide; server_side: PackageSide; 
/**
 * List of URLs to images
 */
gallery: string[] }

export type SettingProfileModel = { name: string; java_id: bigint | null; res: Resolution | null; force_fullscreen: boolean | null; mem_max: number | null; launch_args: string | null; launch_env: string | null; hook_pre: string | null; hook_wrapper: string | null; hook_post: string | null; os_extra: SettingsOsExtra | null }

export type Settings = { global_game_settings: SettingProfileModel; allow_parallel_running_clusters: boolean; enable_gamemode: boolean; discord_enabled: boolean; max_concurrent_requests: bigint; settings_version: number; native_window_frame: boolean }

export type SettingsOsExtra = Record<string, never>

export type Sort = "Relevance" | "Downloads" | "Newest" | "Updated"

/**
 * A game version of Minecraft
 */
export type Version = { 
/**
 * A unique identifier of the version
 */
id: string; 
/**
 * The release type of the version
 */
type: VersionType; 
/**
 * A link to additional information about the version
 */
url: string; 
/**
 * The latest time a file in this version was updated
 */
time: string; 
/**
 * The time this version was released
 */
releaseTime: string; 
/**
 * The SHA1 hash of the additional information about the version
 */
sha1: string; 
/**
 * Whether the version supports the latest player safety features
 */
complianceLevel: number; 
/**
 * The SHA1 hash of the original unmodified Minecraft version's JSON
 * This is only available when using the Pulseflow mirror
 */
originalSha1?: string | null }

/**
 * The version type of Minecraft
 */
export type VersionType = 
/**
 * A major version, which is stable for all players to use
 */
"release" | 
/**
 * An experimental version, which is unstable and used for feature previews and beta testing
 */
"snapshot" | 
/**
 * The oldest versions before the game was released
 */
"old_alpha" | 
/**
 * Early versions of the game
 */
"old_beta"

const ARGS_MAP = { 'events':'{"ingress":["event"],"message":["event"],"process":["event"]}', 'core':'{"removeUser":["uuid"],"writeSettings":["setting"],"updateClusterById":["id","request"],"getScreenshots":["id"],"getClusters":[],"getWorlds":["id"],"getGameVersions":[],"getPackage":["provider","slug"],"getLoadersForVersion":["mc_version"],"getMultiplePackages":["provider","slugs"],"getPackageUser":["provider","slug"],"downloadPackage":["provider","package_id","version_id","cluster_id","skip_compatibility"],"getUsersFromAuthor":["provider","author"],"searchPackages":["provider","query"],"getUser":["uuid"],"getProfileOrDefault":["name"],"updateClusterProfile":["name","profile"],"getPackageVersions":["provider","slug","mc_versions","loaders","offset","limit"],"launchCluster":["id","uuid"],"setDefaultUser":["uuid"],"openMsaLogin":[],"getGlobalProfile":[],"getClusterById":["id"],"getDefaultUser":["fallback"],"readSettings":[],"removeCluster":["id"],"createCluster":["options"],"getUsers":[]}', 'onelauncher':'{"set_window_style":["decorations"],"return_error":[],"open_dev_tools":[]}' }
export type Router = { 'core': { getClusters: () => Promise<ClusterModel[]>, 
getClusterById: (id: bigint) => Promise<ClusterModel | null>, 
removeCluster: (id: bigint) => Promise<null>, 
createCluster: (options: CreateCluster) => Promise<ClusterModel>, 
launchCluster: (id: bigint, uuid: string | null) => Promise<null>, 
updateClusterById: (id: bigint, request: ClusterUpdate) => Promise<null>, 
getScreenshots: (id: bigint) => Promise<string[]>, 
getWorlds: (id: bigint) => Promise<string[]>, 
getProfileOrDefault: (name: string | null) => Promise<SettingProfileModel>, 
getGlobalProfile: () => Promise<SettingProfileModel>, 
updateClusterProfile: (name: string, profile: ProfileUpdate) => Promise<SettingProfileModel>, 
getGameVersions: () => Promise<Version[]>, 
getLoadersForVersion: (mcVersion: string) => Promise<GameLoader[]>, 
getUsers: () => Promise<MinecraftCredentials[]>, 
getUser: (uuid: string) => Promise<MinecraftCredentials | null>, 
removeUser: (uuid: string) => Promise<null>, 
getDefaultUser: (fallback: boolean | null) => Promise<MinecraftCredentials | null>, 
setDefaultUser: (uuid: string | null) => Promise<null>, 
openMsaLogin: () => Promise<MinecraftCredentials | null>, 
readSettings: () => Promise<Settings>, 
writeSettings: (setting: Settings) => Promise<null>, 
searchPackages: (provider: Provider, query: SearchQuery) => Promise<Paginated<SearchResult>>, 
getPackage: (provider: Provider, slug: string) => Promise<ManagedPackage>, 
getMultiplePackages: (provider: Provider, slugs: string[]) => Promise<ManagedPackage[]>, 
getPackageVersions: (provider: Provider, slug: string, mcVersions: string[] | null, loaders: GameLoader[] | null, offset: bigint, limit: bigint) => Promise<Paginated<ManagedVersion>>, 
getPackageUser: (provider: Provider, slug: string) => Promise<ManagedUser>, 
downloadPackage: (provider: Provider, packageId: string, versionId: string, clusterId: bigint, skipCompatibility: boolean | null) => Promise<PackageModel>, 
getUsersFromAuthor: (provider: Provider, author: PackageAuthor) => Promise<ManagedUser[]> },
'events': { ingress: (event: IngressPayload) => Promise<void>, 
message: (event: MessagePayload) => Promise<void>, 
process: (event: ProcessPayload) => Promise<void> },
'onelauncher': { return_error: () => Promise<null>, 
open_dev_tools: () => Promise<void>, 
set_window_style: (decorations: boolean) => Promise<void> } };


export type { InferCommandOutput }
export const createTauRPCProxy = () => createProxy<Router>(ARGS_MAP)
